name: Deploy Backend Code and Model

on:
  push:
    branches:
      - main
    paths:
      - "backend/**"
      - "backend/requirements.txt"
      - "backend/models/**"
      - ".github/workflows/update-backend.yml"
  workflow_dispatch: {}

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-2
  EC2_INSTANCE_TAG: icu-backend
  # NOTE: set this repo secret MODEL_S3_BUCKET_NAME to the bucket created by Terraform.
  S3_BUCKET_NAME: ${{ secrets.MODEL_S3_BUCKET_NAME }}
  APP_DIR: /opt/app/ICU
  BACKEND_SERVICE: fastapi

jobs:
  upload-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Debug info
        run: |
          echo "GITHUB_REF=$GITHUB_REF"
          echo "GITHUB_SHA=$GITHUB_SHA"
          aws --version || true
          uname -a
          echo "Assuming role: arn:aws:iam::601559288497:role/GitHubActionsTerraformRole"

      - name: Configure AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: arn:aws:iam::601559288497:role/GitHubActionsTerraformRole
          aws-region: ${{ env.AWS_REGION }}

      - name: Show assumed identity & check bucket
        id: check_bucket
        run: |
          set -euo pipefail
          # Use env value populated by GitHub (secret) or fallback to 'icu-models'
          : "${S3_BUCKET_NAME:=icu-models}"
          echo "Using S3_BUCKET_NAME=$S3_BUCKET_NAME"

          echo "Caller identity:"
          aws sts get-caller-identity --region "$AWS_REGION"

          echo "Checking bucket existence (head-bucket) for: $S3_BUCKET_NAME"
          if aws s3api head-bucket --bucket "$S3_BUCKET_NAME" --region "$AWS_REGION" 2>/dev/null; then
            echo "Bucket $S3_BUCKET_NAME exists and is reachable."
          else
            echo "::error::Bucket '$S3_BUCKET_NAME' not found in region $AWS_REGION or you don't have permission to access it."
            # Fail fast (do not run aws s3 ls which requires ListAllMyBuckets)
            exit 1
          fi

      - name: Upload model directory to S3
        run: |
          set -euo pipefail
          : "${S3_BUCKET_NAME:=icu-models}"
          echo "Uploading backend/models -> s3://$S3_BUCKET_NAME/models/ (region: $AWS_REGION)"
          aws s3 cp backend/models/ s3://"$S3_BUCKET_NAME"/models/ --recursive --region "$AWS_REGION"
          echo "Model upload complete."

      - name: Update EC2 Backend via SSM (send)
        id: send_ssm
        run: |
          set -euo pipefail
          : "${S3_BUCKET_NAME:=icu-models}"

          echo "Finding running EC2 instance by tag: ${EC2_INSTANCE_TAG}"

          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${EC2_INSTANCE_TAG}" "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text \
            --region "$AWS_REGION")

          if [ -z "$INSTANCE_ID" ]; then
            echo "::error::No EC2 instance found with tag Name=${EC2_INSTANCE_TAG}"
            exit 1
          fi

          echo "Instance found: $INSTANCE_ID"

          # Build JSON params file to avoid CLI quoting issues
          cat > /tmp/ssm-params.json <<'JSON'
            {"commands":["bash -lc 'set -euo pipefail; cd /opt/app/ICU || { echo \"App directory not found\"; exit 1; }; sudo -u ubuntu git pull; sudo -u ubuntu /opt/app/ICU/venv/bin/pip install -r /opt/app/ICU/backend/requirements.txt; systemctl daemon-reload; systemctl restart fastapi'"]}
            JSON

          echo "SSM parameters file:"
          cat /tmp/ssm-params.json

          echo "Sending SSM command to instance $INSTANCE_ID..."
          RESPONSE=$(aws ssm send-command \
            --instance-ids "$INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Update backend via SSM" \
            --parameters file:///tmp/ssm-params.json \
            --output json --region "$AWS_REGION") || {
              echo "::error::aws ssm send-command failed"
              echo "Partial/empty response:"
              echo "$RESPONSE"
              exit 1
          }

          echo "Full send-command response: $RESPONSE"

          # Extract CommandId (requires jq). Runner typically has jq installed.
          CMD_ID=$(echo "$RESPONSE" | jq -r '.Command.CommandId' 2>/dev/null || true)

          if [ -z "$CMD_ID" ] || [ "$CMD_ID" = "null" ]; then
            echo "::error::send-command did not return a CommandId. Response:"
            echo "$RESPONSE"
            exit 1
          fi

          echo "SSM Command ID: $CMD_ID"

          # Export outputs for other steps
          echo "cmd_id=$CMD_ID" >> "$GITHUB_OUTPUT"
          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"

      - name: Wait for SSM command and print invocation output
        if: always()
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.send_ssm.outputs.cmd_id }}"
          INSTANCE_ID="${{ steps.send_ssm.outputs.instance_id }}"

          if [ -z "$CMD_ID" ] || [ -z "$INSTANCE_ID" ]; then
            echo "::warning::No CMD_ID or INSTANCE_ID available; skipping invocation polling."
            exit 0
          fi

          echo "Waiting for SSM command $CMD_ID on instance $INSTANCE_ID..."

          # Poll for status until terminal state (or timeout)
          ATTEMPTS=30
          SLEEP_SECONDS=5
          for i in $(seq 1 $ATTEMPTS); do
            STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'Status' --output text --region "$AWS_REGION" 2>/dev/null || echo "Pending")
            echo "Attempt $i/$ATTEMPTS: status=$STATUS"
            if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
              break
            fi
            sleep $SLEEP_SECONDS
          done

          echo "Final invocation details:"
          aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --region "$AWS_REGION" || true
